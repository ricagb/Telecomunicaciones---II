# -*- coding: utf-8 -*-
"""Modulacion.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qce_2PxYjKmZNhF4b-gxeS_wMu5U6fzj
"""

import numpy as np
import matplotlib.pyplot as plt

# Tabla de verdad para 3 bits -> 8 símbolos
tabla_verdad = {
    '000': (1, 0),                   # 0°
    '001': (np.cos(np.pi/4), np.sin(np.pi/4)), # 45°
    '010': (0, 1),                   # 90°
    '011': (-np.cos(np.pi/4), np.sin(np.pi/4)), # 135°
    '100': (-1, 0),                  # 180°
    '101': (-np.cos(np.pi/4), -np.sin(np.pi/4)), # 225°
    '110': (0, -1),                  # 270°
    '111': (np.cos(np.pi/4), -np.sin(np.pi/4)) # 315°
}

# Colores por combinación de 3 bits (RGB binario)
colores_bits = {
    '000': '#000000',  # negro
    '001': '#0000FF',  # azul
    '010': '#00FF00',  # verde
    '011': '#00FFFF',  # cian
    '100': '#FF0000',  # rojo
    '101': '#FF00FF',  # magenta
    '110': '#FFFF00',  # amarillo
    '111': '#FFFFFF'   # blanco
}

# Graficar constelación
plt.figure(figsize=(8, 8))
for bits, (i, q) in tabla_verdad.items():
    plt.plot(i, q, 'o', markersize=12, color=colores_bits[bits], label=bits)
    plt.arrow(0, 0, i, q, head_width=0.05, head_length=0.1, color=colores_bits[bits], alpha=0.7)
    plt.text(i + 0.05, q + 0.05, bits, fontsize=12)

# Personalización del gráfico
plt.title('Diagrama de Constelación y Fasorial de 8QAM (Colores según bits)')
plt.axhline(0, color='gray', lw=1)
plt.axvline(0, color='gray', lw=1)
plt.grid(True, which='both')
plt.xlabel('I (In-phase)')
plt.ylabel('Q (Quadrature)')
plt.legend()
plt.gca().set_aspect('equal', adjustable='box')
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros generales
fs = 1000  # frecuencia de muestreo
fc = 100   # frecuencia de portadora
Ts = 0.01  # duración de símbolo en segundos
t = np.arange(0, Ts, 1/fs)

# Tabla de verdad para 8QAM real (2 amplitudes, 4 fases)
# Primera fila: bits, amplitud, fase en grados
tabla_8qam = {
    '000': (1, 0),
    '001': (1, 90),
    '010': (1, 180),
    '011': (1, 270),
    '100': (1.5, 45),
    '101': (1.5, 135),
    '110': (1.5, 225),
    '111': (1.5, 315),
}

# Colores RGB por bits (3 bits = color)
colores_bits = {
    '000': '#000000',  # negro
    '001': '#0000FF',  # azul
    '010': '#00FF00',  # verde
    '011': '#00FFFF',  # cian
    '100': '#FF0000',  # rojo
    '101': '#FF00FF',  # magenta
    '110': '#FFFF00',  # amarillo
    '111': '#FFFFFF'   # blanco
}

# Diagrama de constelación y fasorial
plt.figure(figsize=(8, 8))
for bits, (amp, phase_deg) in tabla_8qam.items():
    phase_rad = np.deg2rad(phase_deg)
    i = amp * np.cos(phase_rad)
    q = amp * np.sin(phase_rad)
    plt.plot(i, q, 'o', markersize=12, color=colores_bits[bits], label=bits)
    plt.arrow(0, 0, i, q, head_width=0.05, head_length=0.1, color=colores_bits[bits], alpha=0.7)
    plt.text(i + 0.05, q + 0.05, bits, fontsize=12)

plt.title('Diagrama de Constelación y Fasorial 8QAM Real (Colores 3 bits)')
plt.axhline(0, color='gray', lw=1)
plt.axvline(0, color='gray', lw=1)
plt.grid(True, which='both')
plt.xlabel('I (In-phase)')
plt.ylabel('Q (Quadrature)')
plt.legend()
plt.gca().set_aspect('equal', adjustable='box')
plt.xlim(-2, 2)
plt.ylim(-2, 2)
plt.show()

# Simulación de señal modulada 8QAM
plt.figure(figsize=(10, 6))
señal_total = np.array([])

for idx, (bits, (amp, phase_deg)) in enumerate(tabla_8qam.items()):
    phase_rad = np.deg2rad(phase_deg)
    s_t = amp * np.cos(2 * np.pi * fc * t + phase_rad)
    señal_total = np.concatenate((señal_total, s_t))
    plt.plot(t + idx * Ts, s_t, color=colores_bits[bits], label=bits)

plt.title('Señal modulada 8QAM en el tiempo (cada símbolo 3 bits)')
plt.xlabel('Tiempo [s]')
plt.ylabel('Amplitud')
plt.grid(True)
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros generales
fs = 1000  # frecuencia de muestreo
fc = 100   # frecuencia de portadora
Ts = 0.01  # duración de símbolo
t = np.arange(0, Ts, 1/fs)

# Tabla de verdad 16QAM estándar (I y Q toman -3, -1, 1, 3)
# Se organiza en Gray code para robustez ante errores (opcionalmente)
niveles = [-3, -1, 1, 3]
bits_list = [format(i, '04b') for i in range(16)]
tabla_16qam = {}
idx = 0
for i in niveles:
    for q in niveles:
        tabla_16qam[bits_list[idx]] = (i, q)
        idx += 1

# Colores por 4 bits (usar RGB + Alpha de forma didáctica)
def bits_to_color(bits):
    r = int(bits[0]) * 255
    g = int(bits[1]) * 255
    b = int(bits[2]) * 255
    a = 0.3 + 0.7 * int(bits[3])  # uso el 4to bit como alpha extra
    return (r/255, g/255, b/255, a)

# Diagrama de constelación y fasorial
plt.figure(figsize=(8, 8))
for bits, (i, q) in tabla_16qam.items():
    color = bits_to_color(bits)
    plt.plot(i, q, 'o', markersize=12, color=color, label=bits)
    plt.arrow(0, 0, i, q, head_width=0.3, head_length=0.3, color=color, alpha=0.7)
    plt.text(i + 0.2, q + 0.2, bits, fontsize=10)

plt.title('Diagrama de Constelación y Fasorial 16QAM (Colores 4 bits)')
plt.axhline(0, color='gray', lw=1)
plt.axvline(0, color='gray', lw=1)
plt.grid(True, which='both')
plt.xlabel('I (In-phase)')
plt.ylabel('Q (Quadrature)')
plt.gca().set_aspect('equal', adjustable='box')
plt.xlim(-4, 4)
plt.ylim(-4, 4)
plt.show()

# Señal modulada 16QAM en el tiempo
plt.figure(figsize=(12, 6))
señal_total = np.array([])

for idx, (bits, (i, q)) in enumerate(tabla_16qam.items()):
    s_t = i * np.cos(2 * np.pi * fc * t) + q * np.sin(2 * np.pi * fc * t)
    señal_total = np.concatenate((señal_total, s_t))
    plt.plot(t + idx * Ts, s_t, color=bits_to_color(bits), label=bits)

plt.title('Señal modulada 16QAM en el tiempo (cada símbolo 4 bits)')
plt.xlabel('Tiempo [s]')
plt.ylabel('Amplitud')
plt.grid(True)
plt.legend(ncol=4, fontsize=8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parámetros generales
fs = 1000  # frecuencia de muestreo
fc = 100   # frecuencia de portadora
Ts = 0.01  # duración de símbolo
t = np.arange(0, Ts, 1/fs)

# Tabla de verdad 16PSK
bits_list = [format(i, '04b') for i in range(16)]
tabla_16psk = {}
for idx, bits in enumerate(bits_list):
    phase_deg = idx * 360 / 16  # 22.5° por símbolo
    tabla_16psk[bits] = (1, phase_deg)

# Colores por 4 bits (RGB + Alpha)
def bits_to_color(bits):
    r = int(bits[0]) * 255
    g = int(bits[1]) * 255
    b = int(bits[2]) * 255
    a = 0.3 + 0.7 * int(bits[3])
    return (r/255, g/255, b/255, a)

# Diagrama de constelación y fasorial
plt.figure(figsize=(8, 8))
for bits, (amp, phase_deg) in tabla_16psk.items():
    phase_rad = np.deg2rad(phase_deg)
    i = amp * np.cos(phase_rad)
    q = amp * np.sin(phase_rad)
    plt.plot(i, q, 'o', markersize=12, color=bits_to_color(bits), label=bits)
    plt.arrow(0, 0, i, q, head_width=0.05, head_length=0.1, color=bits_to_color(bits), alpha=0.7)
    plt.text(i + 0.05, q + 0.05, bits, fontsize=10)

plt.title('Diagrama de Constelación y Fasorial 16PSK (Colores 4 bits)')
plt.axhline(0, color='gray', lw=1)
plt.axvline(0, color='gray', lw=1)
plt.grid(True, which='both')
plt.xlabel('I (In-phase)')
plt.ylabel('Q (Quadrature)')
plt.gca().set_aspect('equal', adjustable='box')
plt.xlim(-1.5, 1.5)
plt.ylim(-1.5, 1.5)
plt.show()

# Señal modulada 16PSK en el tiempo
plt.figure(figsize=(12, 6))
señal_total = np.array([])

for idx, (bits, (amp, phase_deg)) in enumerate(tabla_16psk.items()):
    phase_rad = np.deg2rad(phase_deg)
    s_t = amp * np.cos(2 * np.pi * fc * t + phase_rad)
    señal_total = np.concatenate((señal_total, s_t))
    plt.plot(t + idx * Ts, s_t, color=bits_to_color(bits), label=bits)

plt.title('Señal modulada 16PSK en el tiempo (cada símbolo 4 bits)')
plt.xlabel('Tiempo [s]')
plt.ylabel('Amplitud')
plt.grid(True)
plt.legend(ncol=4, fontsize=8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

fs = 1000
fc = 100
Ts = 0.01
t = np.arange(0, Ts, 1/fs)

# Tabla de verdad 8QAM
tabla_8qam = {
    '000': (1, 0),
    '001': (1, 90),
    '010': (1, 180),
    '011': (1, 270),
    '100': (1.5, 45),
    '101': (1.5, 135),
    '110': (1.5, 225),
    '111': (1.5, 315)
}

def bits_to_color(bits):
    r = int(bits[0]) * 255
    g = int(bits[1]) * 255
    b = int(bits[2]) * 255
    return (r/255, g/255, b/255, 0.8)

print("Tabla de verdad 8QAM")
print("Bits  Amplitud  Fase (°)  I       Q")
for bits, (amp, phase) in tabla_8qam.items():
    i = amp * np.cos(np.deg2rad(phase))
    q = amp * np.sin(np.deg2rad(phase))
    print(f"{bits}   {amp}        {phase}     {i:.2f}   {q:.2f}")

# Diagrama de constelación y fasorial
plt.figure(figsize=(8, 8))
for bits, (amp, phase) in tabla_8qam.items():
    i = amp * np.cos(np.deg2rad(phase))
    q = amp * np.sin(np.deg2rad(phase))
    plt.plot(i, q, 'o', markersize=12, color=bits_to_color(bits), label=bits)
    plt.arrow(0, 0, i, q, head_width=0.05, head_length=0.1, color=bits_to_color(bits), alpha=0.7)
    plt.text(i + 0.05, q + 0.05, bits)

plt.title('8QAM - Diagrama de constelación y fasorial')
plt.axhline(0, color='gray')
plt.axvline(0, color='gray')
plt.grid(True)
plt.gca().set_aspect('equal', adjustable='box')
plt.show()

# Señal de salida
plt.figure(figsize=(12, 6))
señal_total = np.array([])
for idx, (bits, (amp, phase)) in enumerate(tabla_8qam.items()):
    s_t = amp * np.cos(2 * np.pi * fc * t + np.deg2rad(phase))
    señal_total = np.concatenate((señal_total, s_t))
    plt.plot(t + idx * Ts, s_t, color=bits_to_color(bits), label=bits)

plt.title('8QAM - Señal modulada')
plt.xlabel('Tiempo [s]')
plt.grid(True)
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

fs = 1000
fc = 100
Ts = 0.01
t = np.arange(0, Ts, 1/fs)

# Tabla de verdad 16QAM
tabla_16qam = {}
bits_list = [format(i, '04b') for i in range(16)]
I_levels = [-3, -1, 1, 3]
Q_levels = [-3, -1, 1, 3]

idx = 0
for i in I_levels:
    for q in Q_levels:
        bits = bits_list[idx]
        tabla_16qam[bits] = (i, q)
        idx += 1

def bits_to_color(bits):
    r = int(bits[0]) * 255
    g = int(bits[1]) * 255
    b = int(bits[2]) * 255
    return (r/255, g/255, b/255, 0.8)

print("Tabla de verdad 16QAM")
print("Bits   I     Q")
for bits, (i, q) in tabla_16qam.items():
    print(f"{bits}   {i}     {q}")

# Diagrama de constelación y fasorial
plt.figure(figsize=(8, 8))
for bits, (i, q) in tabla_16qam.items():
    plt.plot(i, q, 'o', markersize=12, color=bits_to_color(bits), label=bits)
    plt.arrow(0, 0, i, q, head_width=0.2, head_length=0.4, color=bits_to_color(bits), alpha=0.7)
    plt.text(i + 0.1, q + 0.1, bits)

plt.title('16QAM - Diagrama de constelación y fasorial')
plt.axhline(0, color='gray')
plt.axvline(0, color='gray')
plt.grid(True)
plt.gca().set_aspect('equal', adjustable='box')
plt.show()

# Señal de salida
plt.figure(figsize=(12, 6))
señal_total = np.array([])
for idx, (bits, (i, q)) in enumerate(tabla_16qam.items()):
    s_t = i * np.cos(2 * np.pi * fc * t) + q * np.sin(2 * np.pi * fc * t)
    señal_total = np.concatenate((señal_total, s_t))
    plt.plot(t + idx * Ts, s_t, color=bits_to_color(bits), label=bits)

plt.title('16QAM - Señal modulada')
plt.xlabel('Tiempo [s]')
plt.grid(True)
plt.legend(ncol=4, fontsize=8)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

fs = 1000  # Frecuencia de muestreo
fc = 100   # Frecuencia de la portadora
Ts = 0.01  # Duración de cada símbolo
t = np.arange(0, Ts, 1/fs)  # Vector de tiempo

# Tabla de verdad 16QAM con desfase de 45 grados
tabla_16qam = {}
bits_list = [format(i, '04b') for i in range(16)]
I_levels = [-3, -1, 1, 3]
Q_levels = [-3, -1, 1, 3]

# Aplicar rotación de 45 grados a los puntos de la constelación
theta = np.pi/4  # 45 grados en radianes
idx = 0
for i in I_levels:
    for q in Q_levels:
        bits = bits_list[idx]
        # Rotación de 45 grados
        i_rot = i * np.cos(theta) - q * np.sin(theta)
        q_rot = i * np.sin(theta) + q * np.cos(theta)
        tabla_16qam[bits] = (i_rot, q_rot)
        idx += 1

def bits_to_color(bits):
    """Función para asignar colores a los bits"""
    r = int(bits[0]) * 255
    g = int(bits[1]) * 255
    b = int(bits[2:4], 2) * 63  # Usamos los últimos 2 bits para el canal azul
    return (r/255, g/255, b/255, 0.8)

# Mostrar tabla de verdad
print("Tabla de verdad 16QAM con desfase de 45°")
print("Bits     I         Q")
for bits, (i, q) in tabla_16qam.items():
    print(f"{bits}   {i:.3f}   {q:.3f}")

# Diagrama de constelación y fasorial
plt.figure(figsize=(10, 10))
for bits, (i, q) in tabla_16qam.items():
    plt.plot(i, q, 'o', markersize=12, color=bits_to_color(bits), label=bits)
    plt.arrow(0, 0, i, q, head_width=0.2, head_length=0.3, color=bits_to_color(bits), alpha=0.5)
    plt.text(i + 0.1, q + 0.1, bits, fontsize=8)

plt.title('16QAM con desfase de 45° - Diagrama de constelación')
plt.axhline(0, color='gray')
plt.axvline(0, color='gray')
plt.grid(True)
plt.gca().set_aspect('equal', adjustable='box')
plt.xlabel('Componente I')
plt.ylabel('Componente Q')
plt.show()

# Señal modulada
plt.figure(figsize=(15, 6))
señal_total = np.array([])
for idx, (bits, (i, q)) in enumerate(tabla_16qam.items()):
    s_t = i * np.cos(2 * np.pi * fc * t) + q * np.sin(2 * np.pi * fc * t)
    señal_total = np.concatenate((señal_total, s_t))
    plt.plot(t + idx * Ts, s_t, color=bits_to_color(bits), label=bits)

plt.title('16QAM con desfase de 45° - Señal modulada')
plt.xlabel('Tiempo [s]')
plt.ylabel('Amplitud')
plt.grid(True)
plt.legend(ncol=4, fontsize=8, bbox_to_anchor=(1.05, 1))
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

fs = 1000  # Frecuencia de muestreo
fc = 100   # Frecuencia de la portadora
Ts = 0.01  # Duración de cada símbolo
t = np.arange(0, Ts, 1/fs)  # Vector de tiempo

# Tabla de verdad 8QAM con desfase de 45 grados
tabla_8qam = {
    '000': (1, 45),
    '001': (1, 135),
    '010': (1, 225),
    '011': (1, 315),
    '100': (1.5, 0),
    '101': (1.5, 90),
    '110': (1.5, 180),
    '111': (1.5, 270)
}

def bits_to_color(bits):
    """Función para asignar colores a los bits"""
    r = int(bits[0]) * 255
    g = int(bits[1]) * 255
    b = int(bits[2]) * 255
    return (r/255, g/255, b/255, 0.8)

# Mostrar tabla de verdad
print("Tabla de verdad 8QAM con desfase de 45°")
print("Bits  Amplitud  Fase (°)  I       Q")
for bits, (amp, phase) in tabla_8qam.items():
    i = amp * np.cos(np.deg2rad(phase))
    q = amp * np.sin(np.deg2rad(phase))
    print(f"{bits}   {amp}        {phase}     {i:.2f}   {q:.2f}")

# Diagrama de constelación y fasorial
plt.figure(figsize=(8, 8))
for bits, (amp, phase) in tabla_8qam.items():
    i = amp * np.cos(np.deg2rad(phase))
    q = amp * np.sin(np.deg2rad(phase))
    plt.plot(i, q, 'o', markersize=12, color=bits_to_color(bits), label=bits)
    plt.arrow(0, 0, i, q, head_width=0.05, head_length=0.1, color=bits_to_color(bits), alpha=0.7)
    plt.text(i + 0.05, q + 0.05, bits)

plt.title('8QAM con desfase de 45° - Diagrama de constelación')
plt.axhline(0, color='gray')
plt.axvline(0, color='gray')
plt.grid(True)
plt.gca().set_aspect('equal', adjustable='box')
plt.xlabel('Componente I')
plt.ylabel('Componente Q')
plt.show()

# Señal modulada
plt.figure(figsize=(12, 6))
señal_total = np.array([])
for idx, (bits, (amp, phase)) in enumerate(tabla_8qam.items()):
    s_t = amp * np.cos(2 * np.pi * fc * t + np.deg2rad(phase))
    señal_total = np.concatenate((señal_total, s_t))
    plt.plot(t + idx * Ts, s_t, color=bits_to_color(bits), label=bits)

plt.title('8QAM con desfase de 45° - Señal modulada')
plt.xlabel('Tiempo [s]')
plt.ylabel('Amplitud')
plt.grid(True)
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

fs = 1000
fc = 100
Ts = 0.01
t = np.arange(0, Ts, 1/fs)

# Tabla de verdad 16PSK
tabla_16psk = {}
bits_list = [format(i, '04b') for i in range(16)]
for idx, bits in enumerate(bits_list):
    phase_deg = idx * 360 / 16
    tabla_16psk[bits] = (1, phase_deg)

def bits_to_color(bits):
    r = int(bits[0]) * 255
    g = int(bits[1]) * 255
    b = int(bits[2]) * 255
    return (r/255, g/255, b/255, 0.8)

print("Tabla de verdad 16PSK")
print("Bits   Amplitud  Fase (°)  I       Q")
for bits, (amp, phase) in tabla_16psk.items():
    i = amp * np.cos(np.deg2rad(phase))
    q = amp * np.sin(np.deg2rad(phase))
    print(f"{bits}   {amp}        {phase}     {i:.3f}   {q:.3f}")

# Diagrama de constelación y fasorial
plt.figure(figsize=(8, 8))
for bits, (amp, phase) in tabla_16psk.items():
    i = amp * np.cos(np.deg2rad(phase))
    q = amp * np.sin(np.deg2rad(phase))
    plt.plot(i, q, 'o', markersize=12, color=bits_to_color(bits), label=bits)
    plt.arrow(0, 0, i, q, head_width=0.05, head_length=0.1, color=bits_to_color(bits), alpha=0.7)
    plt.text(i + 0.05, q + 0.05, bits)

plt.title('16PSK - Diagrama de constelación y fasorial')
plt.axhline(0, color='gray')
plt.axvline(0, color='gray')
plt.grid(True)
plt.gca().set_aspect('equal', adjustable='box')
plt.show()

# Señal de salida
plt.figure(figsize=(12, 6))
señal_total = np.array([])
for idx, (bits, (amp, phase)) in enumerate(tabla_16psk.items()):
    s_t = amp * np.cos(2 * np.pi * fc * t + np.deg2rad(phase))
    señal_total = np.concatenate((señal_total, s_t))
    plt.plot(t + idx * Ts, s_t, color=bits_to_color(bits), label=bits)

plt.title('16PSK - Señal modulada')
plt.xlabel('Tiempo [s]')
plt.grid(True)
plt.legend(ncol=4, fontsize=8)
plt.show()