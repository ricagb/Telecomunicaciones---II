# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sd1n9IHbJWKhwtMkqQ76Fo3nSPzzz497
"""

import numpy as np
import matplotlib.pyplot as plt
from ipywidgets import interact, Dropdown, Output, VBox
from matplotlib import gridspec
import pandas as pd

out = Output()

def get_constellation_and_truth_table(modulation_type):
    if modulation_type == 'QPSK':
        mapping = {
            '00': 1+1j,
            '01': 1-1j,
            '11': -1-1j,
            '10': -1+1j
        }
    elif modulation_type == '8PSK':
        mapping = {}
        for i in range(8):
            bits = format(i, '03b')
            phase = i * (2 * np.pi / 8)
            mapping[bits] = np.exp(1j * phase)
    elif modulation_type == '8QAM':
        bits_list = ['000', '001', '010', '011', '100', '101', '110', '111']
        symbols = [1+3j, 3+1j, 3-1j, 1-3j, -1+3j, -3+1j, -3-1j, -1-3j]
        mapping = dict(zip(bits_list, symbols))
    elif modulation_type == '16QAM':
        mapping = {}
        i = 0
        for re in [-3, -1, 1, 3]:
            for im in [-3, -1, 1, 3]:
                bits = format(i, '04b')
                mapping[bits] = re + 1j*im
                i += 1
    else:
        raise ValueError("Modulación no soportada")

    return mapping

def generate_data(mapping, num_symbols=100):
    symbols = list(mapping.values())
    return np.random.choice(symbols, num_symbols)

def plot_all(modulation_type):
    mapping = get_constellation_and_truth_table(modulation_type)
    data = generate_data(mapping)

    fig = plt.figure(figsize=(15, 4))
    gs = gridspec.GridSpec(1, 3, width_ratios=[1, 1, 1])

    # Diagrama de salida
    ax0 = plt.subplot(gs[0])
    ax0.plot(data.real, label='I (In-Phase)')
    ax0.plot(data.imag, label='Q (Quadrature)')
    ax0.set_title(f'{modulation_type} - Señal de salida')
    ax0.set_xlabel('Tiempo')
    ax0.set_ylabel('Amplitud')
    ax0.grid(True)
    ax0.legend()

    # Diagrama de constelación
    ax1 = plt.subplot(gs[1])
    ax1.scatter(data.real, data.imag, color='blue')
    ax1.set_title(f'{modulation_type} - Diagrama de Constelación')
    ax1.set_xlabel('I')
    ax1.set_ylabel('Q')
    ax1.grid(True)
    ax1.axhline(0, color='gray', lw=0.5)
    ax1.axvline(0, color='gray', lw=0.5)

    # Diagrama fasorial
    ax2 = plt.subplot(gs[2])
    for sym in data:
        ax2.arrow(0, 0, sym.real, sym.imag, head_width=0.2, head_length=0.2, fc='red', ec='red', alpha=0.5)
    ax2.set_title(f'{modulation_type} - Diagrama Fasorial')
    ax2.set_xlabel('I')
    ax2.set_ylabel('Q')
    ax2.set_xlim([-4, 4])
    ax2.set_ylim([-4, 4])
    ax2.grid(True)
    ax2.axhline(0, color='gray', lw=0.5)
    ax2.axvline(0, color='gray', lw=0.5)
    ax2.set_aspect('equal')

    plt.tight_layout()
    plt.show()

    # Mostrar tabla de verdad con ángulo, magnitud y QIC
    with out:
        out.clear_output()
        rows = []
        for bits, val in mapping.items():
            magnitude = np.abs(val)
            angle = np.angle(val, deg=True)
            qic = f"{val.real:.2f} + j{val.imag:.2f}"
            rows.append((bits, round(angle, 2), round(magnitude, 2), qic))

        df = pd.DataFrame(rows, columns=['Bits', 'Ángulo (°)', 'Magnitud', 'QIC'])
        display(df)

# Widget interactivo
interact_ui = Dropdown(
    options=['QPSK', '8PSK', '8QAM', '16QAM'],
    value='QPSK',
    description='Modulación:',
    style={'description_width': 'initial'}
)

interact(lambda modulation_type: plot_all(modulation_type), modulation_type=interact_ui)

# Mostrar tabla de verdad
VBox([interact_ui, out])

