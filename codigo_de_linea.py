# -*- coding: utf-8 -*-
"""Codigo de Linea.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14v07awp7BMc1DXbBoscbW-DG6UCZy-5v
"""

bits = [1, 0, 1, 1, 0, 0, 1]

import numpy as np
import matplotlib.pyplot as plt

def plot_line_coding(signal, bits, title="Line Coding"):
    plt.figure(figsize=(10, 2))
    t = np.arange(0, len(signal), 1)
    plt.step(t, signal, where='post')
    plt.ylim(-2, 2)
    plt.title(title)
    plt.grid(True)
    plt.xlabel("Tiempo")
    plt.ylabel("Nivel")
    plt.xticks(np.arange(0, len(bits)*2, 2), bits)
    plt.show()

def nrz(bits):
    signal = []
    for bit in bits:
        level = 1 if bit == 1 else -1
        signal.extend([level, level])
    return signal

def rz(bits):
    signal = []
    for bit in bits:
        if bit == 1:
            signal.extend([1, 0])
        else:
            signal.extend([-1, 0])
    return signal

def ami(bits):
    signal = []
    last = -1
    for bit in bits:
        if bit == 1:
            last *= -1
            signal.extend([last, 0])
        else:
            signal.extend([0, 0])
    return signal

def cmi(bits):
    signal = []
    last = 1
    for bit in bits:
        if bit == 0:
            signal.extend([1, 0])
        else:
            last *= -1
            signal.extend([0, last])
    return signal

def manchester(bits):
    signal = []
    for bit in bits:
        if bit == 1:
            signal.extend([1, -1])
        else:
            signal.extend([-1, 1])
    return signal

def manchester_diferencial(bits):
    signal = []
    level = -1
    for bit in bits:
        if bit == 1:
            level *= -1
        signal.extend([level, -level])
    return signal

def hdb3(bits):
    signal = []
    last_pulse = -1  # -1: no señal previa, 1: positivo, -1: negativo
    zero_count = 0
    pulse_count = 0  # para contar los pulsos entre violaciones

    for bit in bits:
        if bit == 1:
            zero_count = 0
            last_pulse *= -1
            signal.append(last_pulse)
            pulse_count += 1
        else:
            zero_count += 1
            if zero_count == 4:
                if pulse_count % 2 == 0:
                    # B00V
                    signal[-3:] = [0, 0, 0]  # Sobreescribimos los últimos 3 ceros
                    last_pulse *= -1
                    signal.append(last_pulse)  # V
                    pulse_count += 1
                else:
                    # 000V
                    signal.extend([0, 0, 0])
                    signal.append(last_pulse)  # V (igual que último pulso anterior)
                zero_count = 0
                pulse_count = 0
            else:
                signal.append(0)
    return signal

import numpy as np
import matplotlib.pyplot as plt

# Parámetros globales
bitrate = 1  # bits por segundo
T = 1 / bitrate
samples_per_bit = 100

# Función general para graficar
def plot_line_code(t, y, title, ax):
    ax.plot(t, y, drawstyle='steps-post')
    ax.set_title(title)
    ax.set_ylim(-2, 2)
    ax.grid(True)
    ax.set_xlabel("Tiempo")
    ax.set_ylabel("Nivel")

# Función para generar tiempo
def get_time(bits):
    return np.linspace(0, len(bits)*T, len(bits)*samples_per_bit)

# Codificación NRZ
def encode_nrz(bits):
    y = np.repeat(bits, samples_per_bit)
    y = np.where(y == 0, -1, 1)
    return get_time(bits), y

# Codificación RZ (Retorno a cero)
def encode_rz(bits):
    y = []
    for bit in bits:
        if bit == 1:
            y += [1]*int(samples_per_bit/2) + [0]*int(samples_per_bit/2)
        else:
            y += [-1]*int(samples_per_bit/2) + [0]*int(samples_per_bit/2)
    return get_time(bits), np.array(y)

# AMI
def encode_ami(bits):
    y = []
    last = -1
    for bit in bits:
        if bit == 0:
            y += [0]*samples_per_bit
        else:
            last *= -1
            y += [last]*samples_per_bit
    return get_time(bits), np.array(y)

# CMI
def encode_cmi(bits):
    y = []
    last = -1
    for bit in bits:
        if bit == 0:
            y += [1]*int(samples_per_bit/2) + [-1]*int(samples_per_bit/2)
        else:
            last *= -1
            y += [last]*samples_per_bit
    return get_time(bits), np.array(y)

# Manchester
def encode_manchester(bits):
    y = []
    for bit in bits:
        if bit == 1:
            y += [1]*int(samples_per_bit/2) + [-1]*int(samples_per_bit/2)
        else:
            y += [-1]*int(samples_per_bit/2) + [1]*int(samples_per_bit/2)
    return get_time(bits), np.array(y)

# Manchester Diferencial
def encode_differential_manchester(bits):
    y = []
    level = 1
    for bit in bits:
        if bit == 0:
            level *= -1
            y += [level]*int(samples_per_bit/2)
            level *= -1
            y += [level]*int(samples_per_bit/2)
        else:
            y += [level]*int(samples_per_bit/2)
            level *= -1
            y += [level]*int(samples_per_bit/2)
    return get_time(bits), np.array(y)

# HDB3
def encode_hdb3(bits):
    y = []
    count = 0  # cuenta de 1's
    last_pulse = -1
    zeros = 0
    for bit in bits:
        if bit == 1:
            zeros = 0
            count += 1
            last_pulse *= -1
            y += [last_pulse]*samples_per_bit
        else:
            zeros += 1
            if zeros == 4:
                if count % 2 == 0:
                    y += [0]*3*samples_per_bit
                    last_pulse *= -1
                    y += [last_pulse]*samples_per_bit  # violación
                    count = 0
                else:
                    y += [0]*samples_per_bit
                    last_pulse *= -1
                    y += [last_pulse]*samples_per_bit
                    y += [0]*samples_per_bit
                    last_pulse *= -1
                    y += [last_pulse]*samples_per_bit
                    count = 0
                zeros = 0
            else:
                y += [0]*samples_per_bit
    t = np.linspace(0, len(y)/samples_per_bit, len(y))
    return t, np.array(y)

# ========== MAIN ==========
# Ingresar tus bits
bits = [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1]

# Preparar subplots
fig, axs = plt.subplots(4, 2, figsize=(15, 12))
fig.suptitle("Codificaciones de Línea", fontsize=16)

# Lista de codificaciones y funciones
codificaciones = [
    ("NRZ", encode_nrz),
    ("RZ", encode_rz),
    ("AMI", encode_ami),
    ("CMI", encode_cmi),
    ("Manchester", encode_manchester),
    ("Manchester Diferencial", encode_differential_manchester),
    ("HDB3", encode_hdb3)
]

# Dibujar cada codificación
for i, (titulo, codificador) in enumerate(codificaciones):
    fila = i // 2
    columna = i % 2
    t, y = codificador(bits)
    plot_line_code(t, y, titulo, axs[fila][columna])

# Ocultar subplot extra si hay impares
axs[3][1].axis('off')
plt.tight_layout(rect=[0, 0, 1, 0.97])
plt.show()