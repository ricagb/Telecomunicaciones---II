# -*- coding: utf-8 -*-
"""8PSK.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RuBuZFQvfr7IRxfGb6F0s6rzp5p3jsfr
"""



import numpy as np
import matplotlib.pyplot as plt

# ---------------- Tabla Visual de Verdad 8-PSK ----------------
table_data = [["Símbolo", "Ángulo (°)", "Parte Real", "Parte Imaginaria", "Bits"]]
for bits, sym in bit_symbol_map.items():
    angle_deg = np.angle(sym, deg=True) % 360
    table_data.append([f"{sym:.2f}", f"{angle_deg:.1f}", f"{np.real(sym):.2f}", f"{np.imag(sym):.2f}", bits])

plt.figure(figsize=(9, 5))
plt.axis("off")
table = plt.table(cellText=table_data, colLabels=None, loc='center', cellLoc='center')
table.auto_set_font_size(False)
table.set_fontsize(10)
table.scale(1, 1.5)
plt.title("Tabla de Verdad 8-PSK (Símbolos y Bits)", pad=20)
plt.show()


# Generar símbolos aleatorios
def generate_8psk_symbols(n_symbols, bit_symbol_map):
    bit_list = list(bit_symbol_map.keys())
    symbol_list = list(bit_symbol_map.values())
    indices = np.random.choice(len(symbol_list), n_symbols)
    symbols = [symbol_list[i] for i in indices]
    bits = [bit_list[i] for i in indices]
    return np.array(symbols), bits, indices

# Modulación PSK
def modulate_psk(symbols, indices, fc=10, fs=1000, symbol_duration=0.1):
    samples_per_symbol = int(fs * symbol_duration)
    t = np.arange(0, len(symbols) * symbol_duration, 1/fs)
    signal = np.zeros_like(t)
    for i, s in enumerate(symbols):
        idx = slice(i * samples_per_symbol, (i+1) * samples_per_symbol)
        t_segment = t[idx]
        signal[idx] = np.real(s) * np.cos(2*np.pi*fc*t_segment) - np.imag(s) * np.sin(2*np.pi*fc*t_segment)
    return t, signal, samples_per_symbol

# Tabla de verdad
bit_symbol_map = get_8psk_map()
print("Tabla de Verdad 8-PSK (bits → símbolo complejo):")
for bits, sym in bit_symbol_map.items():
    print(f"{bits} → {sym}")

# Colores únicos por símbolo
M = 8
cmap = plt.cm.get_cmap("tab10", M)
colors = [cmap(i) for i in range(M)]

# Generación y modulación
n = 16
symbols, bits_used, indices = generate_8psk_symbols(n, bit_symbol_map)
t, psk_signal, sps = modulate_psk(symbols, indices)

# Señal modulada con colores
plt.figure(figsize=(12, 3))
for i in range(n):
    idx_range = slice(i * sps, (i + 1) * sps)
    plt.plot(t[idx_range], psk_signal[idx_range], color=colors[indices[i]], label=bits_used[i])
plt.title("Señal Modulada 8-PSK")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)
plt.legend(title="Bits", bbox_to_anchor=(1.05, 1), loc="upper left")
plt.tight_layout()
plt.show()

# Diagrama de constelación
plt.figure(figsize=(5,5))
for i, sym in enumerate(symbols):
    plt.scatter(np.real(sym), np.imag(sym), color=colors[indices[i]], label=bits_used[i])
plt.title("Diagrama de Constelación 8-PSK")
plt.xlabel("In-phase")
plt.ylabel("Quadrature")
plt.axhline(0, color='gray')
plt.axvline(0, color='gray')
plt.grid(True)
plt.axis("equal")
plt.legend(title="Bits", bbox_to_anchor=(1.05, 1), loc="upper left")
plt.tight_layout()
plt.show()

# Diagrama fasorial
plt.figure(figsize=(5,5))
for i, sym in enumerate(symbols):
    plt.arrow(0, 0, np.real(sym), np.imag(sym),
              head_width=0.05, color=colors[indices[i]], length_includes_head=True)
plt.title("Diagrama Fasorial 8-PSK")
plt.xlabel("In-phase")
plt.ylabel("Quadrature")
plt.axhline(0, color='gray')
plt.axvline(0, color='gray')
plt.grid(True)
plt.axis("equal")
plt.tight_layout()
plt.show()