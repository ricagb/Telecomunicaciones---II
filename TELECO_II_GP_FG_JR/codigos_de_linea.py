# -*- coding: utf-8 -*-
"""Codigos_de_Linea.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u__VRsJutSfWLGDF2ffOFyNU7YKZkbL6
"""



import numpy as np
import matplotlib.pyplot as plt
import ipywidgets as widgets
from IPython.display import display, clear_output

# Codificadores

def line_code_rz(bits):
    signal = []
    for b in bits:
        if b == '1':
            signal.extend([1, 0])
        else:
            signal.extend([-1, 0])
    return np.array(signal)

def line_code_nrz(bits, polar=True):
    return np.array([1 if b == '1' else (-1 if polar else 0) for b in bits])

def line_code_ami(bits):
    signal = []
    last = -1
    for b in bits:
        if b == '1':
            last *= -1
            signal.append(last)
        else:
            signal.append(0)
    return np.array(signal)

def line_code_cmi(bits):
    signal = []
    last_pulse = 1
    for b in bits:
        if b == '0':
            signal.extend([1, -1])
        else:
            last_pulse *= -1
            signal.extend([last_pulse, -last_pulse])
    return np.array(signal)

def line_code_manchester(bits):
    signal = []
    for b in bits:
        if b == '1':
            signal.extend([-1, 1])
        else:
            signal.extend([1, -1])
    return np.array(signal)

def line_code_differential_manchester(bits):
    signal = []
    last = 1
    for b in bits:
        if b == '1':
            signal.extend([-last, last])
        else:
            last *= -1
            signal.extend([-last, last])
    return np.array(signal)

def line_code_hdb3(bits):
    ami = []
    last = -1
    zero_count = 0
    pulse_count = 0
    i = 0
    while i < len(bits):
        b = bits[i]
        if b == '1':
            zero_count = 0
            last *= -1
            pulse_count += 1
            ami.append(last)
        else:
            zero_count += 1
            if zero_count == 4:
                if pulse_count % 2 == 0:
                    ami[-3] = last
                    ami.extend([0, 0, 0, last])
                else:
                    ami.extend([0, 0, 0, -last])
                zero_count = 0
                pulse_count += 1
                i += 3
            else:
                ami.append(0)
        i += 1
    return np.array(ami)

# Visualizador

def plot_all_encodings(bits):
    encodings = {
        "RZ": line_code_rz(bits),
        "NRZ": line_code_nrz(bits),
        "AMI": line_code_ami(bits),
        "CMI": line_code_cmi(bits),
        "Manchester": line_code_manchester(bits),
        "Manchester diferencial": line_code_differential_manchester(bits),
        "HDB3": line_code_hdb3(bits)
    }

    for name, signal in encodings.items():
        t = np.arange(0, len(signal), 1)
        plt.figure(figsize=(10, 2))
        plt.step(t, signal, where='post')
        plt.ylim(-2, 2)
        plt.title(f"{name} Encoding")
        plt.xlabel("Time")
        plt.ylabel("Amplitude")
        plt.grid(True)
        plt.tight_layout()
        plt.show()

# Interfaz

bit_input = widgets.Text(value='1011001000', description='Bits:')
run_button = widgets.Button(description="Mostrar Codificaciones")
output = widgets.Output()

def on_button_clicked(b):
    with output:
        output.clear_output()
        bits = bit_input.value.strip()
        if not all(c in '01' for c in bits):
            print("Error: Solo se permiten bits 0 y 1.")
            return
        plot_all_encodings(bits)

run_button.on_click(on_button_clicked)
display(bit_input, run_button, output)