# -*- coding: utf-8 -*-
"""QPSK.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I3raBwnsjzGzKvXyOkwXGYo3XlELGdgG
"""

import numpy as np
import matplotlib.pyplot as plt

# ----------- Tabla de verdad para QPSK (2 bits por símbolo) -----------
bit_symbol_map = {
    '00': 1 + 1j,
    '01': -1 + 1j,
    '11': -1 - 1j,
    '10': 1 - 1j
}

# Normalización de energía unitaria
bit_symbol_map = {k: v / np.sqrt(2) for k, v in bit_symbol_map.items()}
bit_list = list(bit_symbol_map.keys())
symbol_list = list(bit_symbol_map.values())

# ----------- Generar símbolos aleatorios -----------
def generate_qpsk_symbols(n_symbols):
    indices = np.random.choice(len(symbol_list), n_symbols)
    symbols = [symbol_list[i] for i in indices]
    bits = [bit_list[i] for i in indices]
    return np.array(symbols), bits, indices

# ----------- Modulación QPSK en banda pasante -----------
def modulate_qpsk(symbols, fc=10, fs=1000, symbol_duration=0.1):
    t = np.arange(0, len(symbols) * symbol_duration, 1/fs)
    signal = np.zeros_like(t)
    samples_per_symbol = int(fs * symbol_duration)
    for i, s in enumerate(symbols):
        idx = slice(i * samples_per_symbol, (i+1) * samples_per_symbol)
        t_seg = t[idx]
        signal[idx] = np.real(s) * np.cos(2 * np.pi * fc * t_seg) - np.imag(s) * np.sin(2 * np.pi * fc * t_seg)
    return t, signal, samples_per_symbol

# ----------- Configuración para un pulso por símbolo -----------
fc = 10                # Frecuencia de la portadora (Hz)
fs = 1000              # Frecuencia de muestreo (Hz)
symbol_duration = 1/fc # Para que cada símbolo dure exactamente 1 ciclo

# ----------- Generar señal QPSK -----------
n = 8  # Número de símbolos (pares de bits)
symbols, bits_used, indices = generate_qpsk_symbols(n)
t, qpsk_signal, sps = modulate_qpsk(symbols, fc=fc, fs=fs, symbol_duration=symbol_duration)

# ----------- Colores únicos para los símbolos -----------
cmap = plt.cm.get_cmap("tab10", len(symbol_list))
colors = [cmap(i) for i in range(len(symbol_list))]

# ----------- Señal modulada QPSK -----------
plt.figure(figsize=(12, 3))
for i in range(n):
    idx_range = slice(i*sps, (i+1)*sps)
    plt.plot(t[idx_range], qpsk_signal[idx_range], color=colors[indices[i]], label=bits_used[i])
plt.title("Señal QPSK (1 pulso por par de bits)")
plt.xlabel("Tiempo [s]")
plt.ylabel("Amplitud")
plt.grid(True)
plt.legend(title="Bits", bbox_to_anchor=(1.05, 1), loc="upper left")
plt.tight_layout()
plt.show()

# ----------- Diagrama de Constelación QPSK -----------
plt.figure(figsize=(5, 5))
for i, sym in enumerate(symbol_list):
    plt.scatter(np.real(sym), np.imag(sym), color=colors[i], label=bit_list[i], s=100)
plt.title("Constelación QPSK")
plt.xlabel("In-phase (I)")
plt.ylabel("Quadrature (Q)")
plt.axhline(0, color='gray', linewidth=0.5)
plt.axvline(0, color='gray', linewidth=0.5)
plt.grid(True)
plt.axis("equal")
plt.legend(title="Bits", bbox_to_anchor=(1.05, 1), loc="upper left")
plt.tight_layout()
plt.show()

# ----------- Diagrama Fasorial QPSK -----------
plt.figure(figsize=(5, 5))
for i, sym in enumerate(symbol_list):
    plt.arrow(0, 0, np.real(sym), np.imag(sym),
              head_width=0.1, color=colors[i], length_includes_head=True, label=bit_list[i])
plt.title("Diagrama Fasorial QPSK")
plt.xlabel("In-phase (I)")
plt.ylabel("Quadrature (Q)")
plt.axhline(0, color='gray', linewidth=0.5)
plt.axvline(0, color='gray', linewidth=0.5)
plt.grid(True)
plt.axis("equal")
plt.legend(title="Bits", bbox_to_anchor=(1.05, 1), loc="upper left")
plt.tight_layout()
plt.show()